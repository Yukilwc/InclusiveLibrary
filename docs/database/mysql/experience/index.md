# 数据库经验记录

对于 sql 的生成，绝对不可直接用前端参数，拼接进去，那会容易被 sql 注入。
前端参数加入 sql，必定使用占位符，其会自动进行字符串化处理，防止特殊字符污染 sql。

go-zero 中，sql 查询后的 Scan，只能查 10 列，然后扫描赋值到小于等于 10 个 fields 的结构体，如果目标结构体高于 10，
则会报`ErrNotMatchDestination = errors.New("not matching destination to scan")`

## sql 执行顺序

书写顺序 SELECT -> DISTINCT -> FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> LIMIT

执行顺序 FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT

执行顺序解释

1. from 要做数据分析，得先有个表
2. join 一个表可能还不够，两个表甚至多个表都可以，关联条件啥也先不用，可以都来个笛卡儿积先
3. on 在诸多表左右连接后，设定两个表之间的关联键，把不符合条件的全部筛掉
4. where 上三步整合各表，形成一个统一大表；在此大表上，设置筛选条件
5. group by 把指定字段相同的行组合在一起，其余没有加入 group by 的字段，可以用聚合函数如 max/min 等合并
6. having 在 group by 了之后，再度指定筛选条件；注意 where 和 having 是不同的，主要在于中间多了 group by
7. select 在行层面的处理暂告一段落，在列层面再来一波
8. distinct 指定字段去重
9. order by 指定字段排序，升降序
10. limit 指定哪些行

先聚合，再聚合筛选，再 where 通用筛选，分组，

## 多表得查询方式

[关于多表查询和单表查询后组合得问题](https://www.zhihu.com/question/298745803)

多表 join 本质是求解笛卡尔积，然后筛选，把性能压力给了数据库，而且不利于分布式。

如果是一对一，则 join 查询，如果是一对多，则分两次查询

## join 的缺陷

修改表的 schema，单表查询的修改比较容易，join 写的 sql 语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

修改表的 schema，单表查询的修改比较容易，join 写的 sql 语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

修改表的 schema，单表查询的修改比较容易，join 写的 sql 语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

**不使用 join**

在业务层，单表查询出数据后，作为条件给下一个单表查询。也就是子查询。会担心子查询出来的结果集太多。mysql 对 in 的数量没有限制，但是 mysql 限制整条 sql 语句的大小。通过调整参数 max_allowed_packet ，可以修改一条 sql 的最大值。建议在业务上做好处理，限制一次查询出来的结果集是能接受的。

**join 的好处**

join 查询的优势
关联查询的好处是可以做分页，可以用副表的字段做查询条件，在查询的时候，将副表匹配到的字段作为结果集，用主表去 in 它。但是问题来了，如果匹配到的数据量太大就不行了，也会导致返回的分页记录跟实际的不一样，解决的方法可以交给前端，一次性查询，让前端分批显示就可以了，这种解决方案的前提是数据量不太，因为 sql 本身长度有限。

## 分页

分页 sql，必须能查询出，筛选条件内的，全部数据集合，然后才能分页。
例如，查询用户+角色，那么角色的名字也是一个筛选条件。

## 关于子查询

子查询是MvSOL的一项重要的功能，可以帮助我们通过一SOL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因
1. 执行子查询时，MySQL需要为内层查询语的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，生大量的慢查询。
2. 子查询的结果集存储的临时表，不论是内存临时表还是磁临时表都不会存在索引，所以查询性能会受到一定的影响3对于返回结果集比较大的子查询，其对查询性能的影响也越大。
在MySOL中，可以使用连接JOIN查询来替代子查询**连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。
结论:尽量不要使用NOTIN或者 NOT EXISTS，用LEFJOIN XXX ON XX WHERE XX IS NULL替代