# 数据库经验记录

对于 sql 的生成，绝对不可直接用前端参数，拼接进去，那会容易被 sql 注入。
前端参数加入 sql，必定使用占位符，其会自动进行字符串化处理，防止特殊字符污染 sql。

go-zero 中，sql 查询后的 Scan，只能查 10 列，然后扫描赋值到小于等于 10 个 fields 的结构体，如果目标结构体高于 10，
则会报`ErrNotMatchDestination = errors.New("not matching destination to scan")`

## sql 执行顺序

书写顺序 SELECT -> DISTINCT -> FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> LIMIT

执行顺序 FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT

执行顺序解释

1. from 要做数据分析，得先有个表
2. join 一个表可能还不够，两个表甚至多个表都可以，关联条件啥也先不用，可以都来个笛卡儿积先
3. on 在诸多表左右连接后，设定两个表之间的关联键，把不符合条件的全部筛掉
4. where 上三步整合各表，形成一个统一大表；在此大表上，设置筛选条件
5. group by 把指定字段相同的行组合在一起，其余没有加入 group by 的字段，可以用聚合函数如 max/min 等合并
6. having 在 group by 了之后，再度指定筛选条件；注意 where 和 having 是不同的，主要在于中间多了 group by
7. select 在行层面的处理暂告一段落，在列层面再来一波
8. distinct 指定字段去重
9. order by 指定字段排序，升降序
10. limit 指定哪些行

先聚合，再聚合筛选，再 where 通用筛选，分组，

## 多表得查询方式

[关于多表查询和单表查询后组合得问题](https://www.zhihu.com/question/298745803)

多表 join 本质是求解笛卡尔积，然后筛选，把性能压力给了数据库，而且不利于分布式。

如果是一对一，则 join 查询，如果是一对多，则分两次查询

## join 的缺陷

修改表的 schema，单表查询的修改比较容易，join 写的 sql 语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

修改表的 schema，单表查询的修改比较容易，join 写的 sql 语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

修改表的 schema，单表查询的修改比较容易，join 写的 sql 语句要修改，不容易发现，成本比较大，当系统比较大时，不好维护。

**不使用 join**

在业务层，单表查询出数据后，作为条件给下一个单表查询。也就是子查询。会担心子查询出来的结果集太多。mysql 对 in 的数量没有限制，但是 mysql 限制整条 sql 语句的大小。通过调整参数 max_allowed_packet ，可以修改一条 sql 的最大值。建议在业务上做好处理，限制一次查询出来的结果集是能接受的。

**join 的好处**

join 查询的优势
关联查询的好处是可以做分页，可以用副表的字段做查询条件，在查询的时候，将副表匹配到的字段作为结果集，用主表去 in 它。但是问题来了，如果匹配到的数据量太大就不行了，也会导致返回的分页记录跟实际的不一样，解决的方法可以交给前端，一次性查询，让前端分批显示就可以了，这种解决方案的前提是数据量不太，因为 sql 本身长度有限。

## 分页

分页 sql，必须能查询出，筛选条件内的，全部数据集合，然后才能分页。
例如，查询用户+角色，那么角色的名字也是一个筛选条件。

## 关于子查询

子查询是MvSOL的一项重要的功能，可以帮助我们通过一SOL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因
1. 执行子查询时，MySQL需要为内层查询语的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，生大量的慢查询。
2. 子查询的结果集存储的临时表，不论是内存临时表还是磁临时表都不会存在索引，所以查询性能会受到一定的影响3对于返回结果集比较大的子查询，其对查询性能的影响也越大。
在MySOL中，可以使用连接JOIN查询来替代子查询**连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。
结论:尽量不要使用NOTIN或者 NOT EXISTS，用LEFJOIN XXX ON XX WHERE XX IS NULL替代

## 关于sql查询加不加redis缓存问题

你好，这是Bing。我可以帮你了解mysql数据库和redis缓存的关系。

根据我搜索到的信息，mysql数据库是一种关系型数据库，它可以持久化地存储结构化的数据到磁盘上。redis缓存是一种内存数据库，它可以快速地存储和访问键值对类型的数据。mysql数据库和redis缓存可以结合使用，以提高应用程序的性能和可扩展性。

使用redis缓存的主要目的是为了减少对mysql数据库的访问次数，从而降低数据库的负载和延迟。当应用程序需要从mysql数据库查询数据时，它首先会检查redis缓存中是否有对应的结果。如果有，就直接返回缓存中的结果，如果没有，就从mysql数据库中获取结果，并将结果缓存到redis中，以便下次使用。

使用redis缓存的主要挑战是如何保持缓存和数据库之间的数据一致性。当mysql数据库中的数据发生变化时，需要同步更新或删除redis缓存中的数据，否则会导致缓存失效或过期。有几种常用的策略来实现缓存和数据库之间的同步，例如：

缓存失效：当mysql数据库中的数据发生变化时，删除redis缓存中对应的键值对，让下次查询重新从数据库获取结果并缓存。
缓存更新：当mysql数据库中的数据发生变化时，更新redis缓存中对应的键值对，让下次查询直接从缓存获取最新的结果。
缓存过期：给redis缓存中的键值对设置一个过期时间（TTL），当超过这个时间后，自动删除键值对，让下次查询重新从数据库获取结果并缓存。
使用redis缓存时，还需要注意以下几点：

不要将所有的mysql查询都缓存到redis中，只需要缓存那些频繁访问且不经常变化的查询。
不要将所有的mysql修改都同步到redis中，只需要同步那些影响到已经缓存的查询结果的修改。
不要将所有的数据都完全依赖于redis中，只需要将redis作为一个辅助层来提高性能，而不是一个主要层来保证正确性。